var _=Object.defineProperty;var N=(r,e,t)=>e in r?_(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var u=(r,e,t)=>N(r,typeof e!="symbol"?e+"":e,t);const R=(r,e)=>e.some(t=>r instanceof t);let k,D;function z(){return k||(k=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function $(){return D||(D=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const M=new WeakMap,S=new WeakMap,O=new WeakMap,f=new WeakMap,T=new WeakMap;function U(r){const e=new Promise((t,n)=>{const a=()=>{r.removeEventListener("success",o),r.removeEventListener("error",s)},o=()=>{t(p(r.result)),a()},s=()=>{n(r.error),a()};r.addEventListener("success",o),r.addEventListener("error",s)});return e.then(t=>{t instanceof IDBCursor&&M.set(t,r)}).catch(()=>{}),T.set(e,r),e}function V(r){if(S.has(r))return;const e=new Promise((t,n)=>{const a=()=>{r.removeEventListener("complete",o),r.removeEventListener("error",s),r.removeEventListener("abort",s)},o=()=>{t(),a()},s=()=>{n(r.error||new DOMException("AbortError","AbortError")),a()};r.addEventListener("complete",o),r.addEventListener("error",s),r.addEventListener("abort",s)});S.set(r,e)}let E={get(r,e,t){if(r instanceof IDBTransaction){if(e==="done")return S.get(r);if(e==="objectStoreNames")return r.objectStoreNames||O.get(r);if(e==="store")return t.objectStoreNames[1]?void 0:t.objectStore(t.objectStoreNames[0])}return p(r[e])},set(r,e,t){return r[e]=t,!0},has(r,e){return r instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in r}};function K(r){E=r(E)}function F(r){return r===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...t){const n=r.call(w(this),e,...t);return O.set(n,e.sort?e.sort():[e]),p(n)}:$().includes(r)?function(...e){return r.apply(w(this),e),p(M.get(this))}:function(...e){return p(r.apply(w(this),e))}}function H(r){return typeof r=="function"?F(r):(r instanceof IDBTransaction&&V(r),R(r,z())?new Proxy(r,E):r)}function p(r){if(r instanceof IDBRequest)return U(r);if(f.has(r))return f.get(r);const e=H(r);return e!==r&&(f.set(r,e),T.set(e,r)),e}const w=r=>T.get(r);function J(r,e,{blocked:t,upgrade:n,blocking:a,terminated:o}={}){const s=indexedDB.open(r,e),i=p(s);return n&&s.addEventListener("upgradeneeded",c=>{n(p(s.result),c.oldVersion,c.newVersion,p(s.transaction),c)}),t&&s.addEventListener("blocked",c=>t(c.oldVersion,c.newVersion,c)),i.then(c=>{o&&c.addEventListener("close",()=>o()),a&&c.addEventListener("versionchange",l=>a(l.oldVersion,l.newVersion,l))}).catch(()=>{}),i}const W=["get","getKey","getAll","getAllKeys","count"],X=["put","add","delete","clear"],b=new Map;function C(r,e){if(!(r instanceof IDBDatabase&&!(e in r)&&typeof e=="string"))return;if(b.get(e))return b.get(e);const t=e.replace(/FromIndex$/,""),n=e!==t,a=X.includes(t);if(!(t in(n?IDBIndex:IDBObjectStore).prototype)||!(a||W.includes(t)))return;const o=async function(s,...i){const c=this.transaction(s,a?"readwrite":"readonly");let l=c.store;return n&&(l=l.index(i.shift())),(await Promise.all([l[t](...i),a&&c.done]))[0]};return b.set(e,o),o}K(r=>({...r,get:(e,t,n)=>C(e,t)||r.get(e,t,n),has:(e,t)=>!!C(e,t)||r.has(e,t)}));class Y{constructor(){u(this,"db",null);u(this,"DB_NAME","CopilotXDB");u(this,"DB_VERSION",1)}async initialize(){try{this.db=await J(this.DB_NAME,this.DB_VERSION,{upgrade(e){e.objectStoreNames.contains("taskLog")||e.createObjectStore("taskLog",{keyPath:"id"}),e.objectStoreNames.contains("chatLog")||e.createObjectStore("chatLog",{keyPath:"id"}),e.objectStoreNames.contains("agentState")||e.createObjectStore("agentState",{keyPath:"id"}),e.objectStoreNames.contains("authTokens")||e.createObjectStore("authTokens",{keyPath:"providerId"}),e.objectStoreNames.contains("preferences")||e.createObjectStore("preferences",{keyPath:"id"}),e.objectStoreNames.contains("embeddings")||e.createObjectStore("embeddings",{keyPath:"id"})}}),console.log("Memory manager initialized successfully")}catch(e){throw console.error("Failed to initialize memory manager:",e),e}}async addExecutionHistory(e){if(!this.db)throw new Error("Database not initialized");await this.db.add("taskLog",e)}async getExecutionHistory(e){if(!this.db)throw new Error("Database not initialized");return e?(await this.db.getAll("taskLog")).filter(n=>n.planId===e):await this.db.getAll("taskLog")}async getExecutionHistoryByStep(e){if(!this.db)throw new Error("Database not initialized");return(await this.db.getAll("taskLog")).filter(n=>n.stepId===e)}async addConversation(e){if(!this.db)throw new Error("Database not initialized");await this.db.put("chatLog",e)}async getConversation(e){if(!this.db)throw new Error("Database not initialized");return await this.db.get("chatLog",e)}async getAllConversations(){if(!this.db)throw new Error("Database not initialized");return await this.db.getAll("chatLog")}async updateConversation(e,t){if(!this.db)throw new Error("Database not initialized");const n=await this.db.get("chatLog",e);n&&await this.db.put("chatLog",{...n,...t})}async saveAgentState(e){if(!this.db)throw new Error("Database not initialized");await this.db.put("agentState",{id:"current",...e})}async getAgentState(){if(!this.db)throw new Error("Database not initialized");return await this.db.get("agentState","current")}async updateAgentState(e){if(!this.db)throw new Error("Database not initialized");const t=await this.db.get("agentState","current");t?await this.db.put("agentState",{...t,...e}):await this.db.put("agentState",{id:"current",...e})}async saveAuthToken(e){if(!this.db)throw new Error("Database not initialized");await this.db.put("authTokens",e)}async getAuthToken(e){if(!this.db)throw new Error("Database not initialized");return await this.db.get("authTokens",e)}async getAllAuthTokens(){if(!this.db)throw new Error("Database not initialized");return await this.db.getAll("authTokens")}async removeAuthToken(e){if(!this.db)throw new Error("Database not initialized");await this.db.delete("authTokens",e)}async savePreferences(e){if(!this.db)throw new Error("Database not initialized");await this.db.put("preferences",{id:"user",...e})}async getPreferences(){if(!this.db)throw new Error("Database not initialized");return await this.db.get("preferences","user")}async saveEmbeddings(e){if(!this.db)throw new Error("Database not initialized");await this.db.put("embeddings",e)}async getEmbeddings(e){if(!this.db)throw new Error("Database not initialized");return await this.db.get("embeddings",e)}async clearAllData(){if(!this.db)throw new Error("Database not initialized");await this.db.clear("taskLog"),await this.db.clear("chatLog"),await this.db.clear("agentState"),await this.db.clear("authTokens"),await this.db.clear("preferences"),await this.db.clear("embeddings")}async exportData(){const e=await this.getExecutionHistory(),t=await this.getAllConversations(),n=await this.getAgentState(),a=await this.getAllAuthTokens();return{taskLog:e,chatLog:t,agentState:n||{memory:{},preferences:{}},authTokens:a,embeddingStore:void 0}}async importData(e){if(e.taskLog)for(const t of e.taskLog)await this.addExecutionHistory(t);if(e.chatLog)for(const t of e.chatLog)await this.addConversation(t);if(e.agentState&&await this.saveAgentState(e.agentState),e.authTokens)for(const t of e.authTokens)await this.saveAuthToken(t)}}let m;const G=new Uint8Array(16);function q(){if(!m&&(m=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!m))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return m(G)}const d=[];for(let r=0;r<256;++r)d.push((r+256).toString(16).slice(1));function Q(r,e=0){return d[r[e+0]]+d[r[e+1]]+d[r[e+2]]+d[r[e+3]]+"-"+d[r[e+4]]+d[r[e+5]]+"-"+d[r[e+6]]+d[r[e+7]]+"-"+d[r[e+8]]+d[r[e+9]]+"-"+d[r[e+10]]+d[r[e+11]]+d[r[e+12]]+d[r[e+13]]+d[r[e+14]]+d[r[e+15]]}const Z=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),I={randomUUID:Z};function ee(r,e,t){if(I.randomUUID&&!r)return I.randomUUID();r=r||{};const n=r.random||(r.rng||q)();return n[6]=n[6]&15|64,n[8]=n[8]&63|128,Q(n)}class te{constructor(e){u(this,"llmProvider");this.llmProvider=e}async createPlan(e,t){const n=ee(),a=this.buildSystemPrompt(),o=this.buildUserPrompt(e,t),s=[{role:"system",content:a},{role:"user",content:o}];try{const i=await this.llmProvider.chat({messages:s,temperature:.1,maxTokens:2e3}),c=this.parsePlanResponse(i.content);return{id:n,goal:e,steps:c,createdAt:new Date().toISOString(),status:"pending",currentStep:0}}catch(i){throw console.error("Failed to create plan:",i),new Error(`Failed to create plan: ${i}`)}}buildSystemPrompt(){return`You are a task planning agent. Your job is to break down user goals into executable steps.

Available step types:
- tool: Execute a tool with parameters
- wait: Wait for a specified time or condition
- ask: Request user input or clarification
- compute: Perform calculations or data processing

Tool categories available:
- browser: DOM manipulation, navigation, scraping
- communication: Gmail, Notion, Calendar
- system: clipboard, file operations
- web: API calls, web scraping

Format your response as a JSON array of step objects:
[
  {
    "id": "step_1",
    "type": "tool",
    "tool": "tool_name",
    "input": { "param1": "value1" },
    "description": "What this step does"
  }
]

Each step should be specific and actionable. Include error handling and user confirmation for write operations.`}buildUserPrompt(e,t){let n=`Create a plan to: ${e}`;return t&&(n+=`

Context: ${t}`),n+=`

Provide a JSON array of steps to accomplish this goal.`,n}parsePlanResponse(e){try{const t=e.match(/```json\s*([\s\S]*?)\s*```/)||e.match(/\[[\s\S]*\]/);if(!t)throw new Error("No valid JSON found in response");const n=t[1]||t[0],a=JSON.parse(n);return a.map((o,s)=>({id:o.id||`step_${s+1}`,type:o.type,tool:o.tool,input:o.input,description:o.description,next:o.next||(s<a.length-1?`step_${s+2}`:void 0)}))}catch(t){throw console.error("Failed to parse plan response:",t),new Error(`Failed to parse plan: ${t}`)}}async replan(e,t){const n=`Previous plan failed: ${t}
Current plan: ${JSON.stringify(e.steps)}`;return this.createPlan(e.goal,n)}}class re{constructor(){u(this,"tools",new Map);this.registerTools()}registerTool(e){const t=e.getDefinition();this.tools.set(t.name,e)}async executePlan(e){const t={...e,status:"executing"},n={};try{for(let a=0;a<t.steps.length;a++){const o=t.steps[a];t.currentStep=a,console.log(`Executing step ${a+1}: ${o.description||o.type}`);const s=await this.executeStep(o,n);if(n[o.id]=s,!s.success)throw t.status="failed",new Error(`Step ${o.id} failed: ${s.error}`);if(o.condition&&!this.evaluateCondition(o.condition,s)){console.log(`Condition failed for step ${o.id}, skipping`);continue}if(o.type==="wait"&&await this.handleWaitStep(o),o.type==="ask"){const i=await this.handleAskStep(o);n[o.id]={success:!0,data:i}}}return t.status="complete",t.results=n,t}catch(a){throw console.error("Plan execution failed:",a),t.status="failed",a}}async executeStep(e,t){switch(e.type){case"tool":return this.executeToolStep(e,t);case"compute":return this.executeComputeStep(e,t);case"wait":return{success:!0,data:"wait completed"};case"ask":return{success:!0,data:"user input requested"};default:throw new Error(`Unknown step type: ${e.type}`)}}async executeToolStep(e,t){if(!e.tool)throw new Error("Tool step missing tool name");const n=this.tools.get(e.tool);if(!n)throw new Error(`Tool not found: ${e.tool}`);const a={name:e.tool,arguments:this.substituteParameters(e.input||{},t)},o=Date.now();try{const s=await n.execute(a),i=Date.now()-o;return{...s,metadata:{...s.metadata,executionTime:i}}}catch(s){return{success:!1,error:s instanceof Error?s.message:String(s),metadata:{executionTime:Date.now()-o}}}}async executeComputeStep(e,t){var n;try{const a=(n=e.input)==null?void 0:n.expression;if(!a)throw new Error("Compute step missing expression");return{success:!0,data:a,metadata:{executionTime:0}}}catch(a){return{success:!1,error:a instanceof Error?a.message:String(a),metadata:{executionTime:0}}}}async handleWaitStep(e){var n;const t=((n=e.input)==null?void 0:n.duration)||1e3;await new Promise(a=>setTimeout(a,t))}async handleAskStep(e){var t;return((t=e.input)==null?void 0:t.prompt)||"User input requested"}substituteParameters(e,t){if(typeof e=="string")return e.replace(/\{\{([^}]+)\}\}/g,(n,a)=>{var c;const[o,s]=a.split("."),i=t[o];return((c=i==null?void 0:i.data)==null?void 0:c[s])||(i==null?void 0:i.data)||n});if(typeof e=="object"&&e!==null){const n=Array.isArray(e)?[]:{};for(const[a,o]of Object.entries(e))n[a]=this.substituteParameters(o,t);return n}return e}evaluateCondition(e,t){return e==="success"?t.success:e==="failure"?!t.success:!0}registerTools(){}getAvailableTools(){return Array.from(this.tools.keys())}}class ne{async beginAuth(e){throw new Error("Authentication not supported for this provider")}validateAuth(){}async makeRequest(e,t){const n=await fetch(e,{...t,headers:{"Content-Type":"application/json",...t.headers}});if(!n.ok)throw new Error(`HTTP ${n.status}: ${n.statusText}`);return n}parseStreamResponse(e,t){if(!e.body)throw new Error("No response body");const n=e.body.getReader(),a=new TextDecoder;let o="";return new Promise((s,i)=>{(async()=>{var l,h,x;try{for(;;){const{done:g,value:j}=await n.read();if(g){s({content:o,finishReason:"stop"});break}const B=a.decode(j,{stream:!0}).split(`
`);for(const A of B)if(A.startsWith("data: ")){const v=A.slice(6);if(v==="[DONE]"){s({content:o,finishReason:"stop"});return}try{const y=JSON.parse(v);if((x=(h=(l=y.choices)==null?void 0:l[0])==null?void 0:h.delta)!=null&&x.content){const P=y.choices[0].delta.content;o+=P,t==null||t(P)}}catch{}}}}catch(g){i(g)}})()})}}class L extends ne{constructor(t){super();u(this,"id","openai");u(this,"authMode","api_key");u(this,"apiKey",null);u(this,"baseUrl","https://api.openai.com/v1");this.apiKey=t||null}async getCapabilities(){return{streaming:!0,vision:!1,functionCalling:!0,maxTokens:4096,model:"gpt-3.5-turbo"}}async getAuthState(){return this.apiKey?{status:"connected"}:{status:"disconnected"}}async chat(t){var s,i,c;this.validateAuth();const n=`${this.baseUrl}/chat/completions`,a={model:t.model||"gpt-3.5-turbo",messages:t.messages,max_tokens:t.maxTokens||1e3,temperature:t.temperature||.7,stream:t.stream||!1},o={method:"POST",headers:{Authorization:`Bearer ${this.apiKey}`},body:JSON.stringify(a)};try{const l=await this.makeRequest(n,o);if(t.stream)return this.parseStreamResponse(l,t.onToken);{const h=await l.json();return{content:((i=(s=h.choices[0])==null?void 0:s.message)==null?void 0:i.content)||"",usage:h.usage,finishReason:(c=h.choices[0])==null?void 0:c.finish_reason}}}catch(l){throw new Error(`OpenAI API error: ${l}`)}}setApiKey(t){this.apiKey=t}validateAuth(){if(!this.apiKey)throw new Error("OpenAI API key not configured")}}class oe{constructor(){u(this,"tools",new Map);u(this,"categories",new Map)}registerTool(e){const t=e.getDefinition();this.tools.set(t.name,e);const n=t.category||"general";this.categories.has(n)||this.categories.set(n,[]),this.categories.get(n).push(t.name)}unregisterTool(e){this.tools.delete(e);for(const[t,n]of this.categories.entries()){const a=n.indexOf(e);a>-1&&n.splice(a,1)}}getTool(e){return this.tools.get(e)}getAllTools(){return Array.from(this.tools.values())}getToolDefinitions(){return Array.from(this.tools.values()).map(e=>e.getDefinition())}getToolsByCategory(e){return(this.categories.get(e)||[]).map(n=>this.tools.get(n)).filter(Boolean)}getCategories(){return Array.from(this.categories.keys())}async executeTool(e){const t=this.getTool(e.name);if(!t)return{success:!1,error:`Tool not found: ${e.name}`,metadata:{executionTime:0}};try{return await t.execute(e)}catch(n){return{success:!1,error:n instanceof Error?n.message:String(n),metadata:{executionTime:0}}}}validateToolCall(e){if(!this.getTool(e.name))return{valid:!1,errors:[`Tool not found: ${e.name}`]};const n=[];return(!e.arguments||typeof e.arguments!="object")&&n.push("Tool arguments must be an object"),{valid:n.length===0,errors:n}}getAvailableToolsForPlan(){return Array.from(this.tools.keys())}}class ae{getDefinition(){return{name:"browser_scrape",description:"Scrape content from the current webpage",category:"browser",parametersJsonSchema:{type:"object",properties:{selector:{type:"string",description:"CSS selector to target elements"},attribute:{type:"string",description:"Attribute to extract (optional)"},textOnly:{type:"boolean",description:"Extract only text content"}},required:["selector"]}}}async execute(e){var o,s;const{selector:t,attribute:n,textOnly:a}=e.arguments;try{const i=document.querySelectorAll(t),c=[];for(const l of Array.from(i))n?c.push(l.getAttribute(n)):a?c.push((o=l.textContent)==null?void 0:o.trim()):c.push({text:(s=l.textContent)==null?void 0:s.trim(),html:l.innerHTML,tagName:l.tagName,attributes:Object.fromEntries(Array.from(l.attributes).map(h=>[h.name,h.value]))});return{success:!0,data:c,metadata:{executionTime:0}}}catch(i){return{success:!1,error:i instanceof Error?i.message:String(i),metadata:{executionTime:0}}}}}class se{getDefinition(){return{name:"browser_click",description:"Click an element on the current webpage",category:"browser",parametersJsonSchema:{type:"object",properties:{selector:{type:"string",description:"CSS selector for the element to click"}},required:["selector"]}}}async execute(e){const{selector:t}=e.arguments;try{const n=document.querySelector(t);return n?(n.click(),{success:!0,data:{clicked:!0,element:t},metadata:{executionTime:0}}):{success:!1,error:`Element not found: ${t}`,metadata:{executionTime:0}}}catch(n){return{success:!1,error:n instanceof Error?n.message:String(n),metadata:{executionTime:0}}}}}class ie{getDefinition(){return{name:"browser_type",description:"Type text into an input field",category:"browser",parametersJsonSchema:{type:"object",properties:{selector:{type:"string",description:"CSS selector for the input field"},text:{type:"string",description:"Text to type"},clearFirst:{type:"boolean",description:"Clear the field before typing"}},required:["selector","text"]}}}async execute(e){const{selector:t,text:n,clearFirst:a}=e.arguments;try{const o=document.querySelector(t);return o?(a&&(o.value=""),o.value=n,o.dispatchEvent(new Event("input",{bubbles:!0})),o.dispatchEvent(new Event("change",{bubbles:!0})),{success:!0,data:{typed:n,element:t},metadata:{executionTime:0}}):{success:!1,error:`Element not found: ${t}`,metadata:{executionTime:0}}}catch(o){return{success:!1,error:o instanceof Error?o.message:String(o),metadata:{executionTime:0}}}}}class ce{getDefinition(){return{name:"browser_navigate",description:"Navigate to a URL",category:"browser",parametersJsonSchema:{type:"object",properties:{url:{type:"string",description:"URL to navigate to"}},required:["url"]}}}async execute(e){const{url:t}=e.arguments;try{return window.location.href=t,{success:!0,data:{navigated:!0,url:t},metadata:{executionTime:0}}}catch(n){return{success:!1,error:n instanceof Error?n.message:String(n),metadata:{executionTime:0}}}}}class le{constructor(){u(this,"memoryManager");u(this,"planner");u(this,"executor");u(this,"toolRegistry");u(this,"currentProvider",null);this.memoryManager=new Y,this.toolRegistry=new oe,this.initializeComponents()}async initializeComponents(){try{await this.memoryManager.initialize(),this.currentProvider=new L,this.planner=new te(this.currentProvider),this.executor=new re,chrome.storage.local.get(["openai_api_key"],e=>{e.openai_api_key&&this.currentProvider&&(this.currentProvider.setApiKey(e.openai_api_key),console.log("OpenAI API key loaded from storage"))}),this.toolRegistry.registerTool(new ae),this.toolRegistry.registerTool(new se),this.toolRegistry.registerTool(new ie),this.toolRegistry.registerTool(new ce),this.toolRegistry.getAllTools().forEach(e=>{this.executor.registerTool(e)}),console.log("CopilotX background service initialized")}catch(e){console.error("Failed to initialize CopilotX:",e)}}async handleMessage(e,t){try{switch(e.type){case"CREATE_PLAN":return await this.handleCreatePlan(e.goal,e.context);case"EXECUTE_PLAN":return await this.handleExecutePlan(e.planId);case"SET_PROVIDER_API_KEY":return await this.handleSetProviderApiKey(e.providerId,e.apiKey);case"GET_AVAILABLE_TOOLS":return this.toolRegistry.getToolDefinitions();case"EXECUTE_TOOL":return await this.toolRegistry.executeTool(e.toolCall);case"GET_MEMORY":return await this.memoryManager.exportData();case"SAVE_CONVERSATION":return await this.memoryManager.addConversation(e.conversation);default:throw new Error(`Unknown message type: ${e.type}`)}}catch(n){return console.error("Background message handling error:",n),{error:n instanceof Error?n.message:String(n)}}}async handleCreatePlan(e,t){if(!this.currentProvider)throw new Error("No LLM provider configured");const n=await this.planner.createPlan(e,t);return await this.memoryManager.updateAgentState({activePlan:n}),{plan:n}}async handleExecutePlan(e){const t=await this.memoryManager.getAgentState(),n=t==null?void 0:t.activePlan;if(!n||n.id!==e)throw new Error("Plan not found");try{const a=await this.executor.executePlan(n);return await this.memoryManager.updateAgentState({activePlan:a}),{plan:a}}catch(a){const o={...n,status:"failed"};throw await this.memoryManager.updateAgentState({activePlan:o}),a}}async handleSetProviderApiKey(e,t){if(e==="openai"&&this.currentProvider instanceof L)return this.currentProvider.setApiKey(t),await this.memoryManager.saveAuthToken({providerId:e,token:t,expiresAt:void 0}),{success:!0};throw new Error(`Provider ${e} not supported`)}}const ue=new le;chrome.runtime.onMessage.addListener((r,e,t)=>(ue.handleMessage(r,e).then(t).catch(n=>t({error:n.message})),!0));chrome.runtime.onInstalled.addListener(r=>{r.reason==="install"&&console.log("CopilotX extension installed")});chrome.tabs.onUpdated.addListener((r,e,t)=>{e.status==="complete"&&t.url&&console.log("Tab updated:",t.url)});
